// This is your Prisma schema file
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  DOUTOR
  CLINICA_ADMIN
  SUPER_ADMIN
  SECRETARIA
}

enum ChatStatus {
  BOT
  HANDOFF
  CLOSED
}

enum SenderType {
  IA
  PACIENTE
  DOUTOR
  TOOL
}

model Clinica {
  id       Int     @id @default(autoincrement())
  nome     String
  cnpj     String? @unique
  endereco String?
  telefone String?
  email    String?
  site     String?
  ativo    Boolean @default(true)

  // --- Campos para o Multi-Tenant (WhatsApp Opção 2) ---
  // 1. Chaves da API do WhatsApp (que o admin da clínica vai preencher no painel)
  whatsappToken   String?
  whatsappPhoneId String?

  // 2. Chaves do Webhook Dinâmico (que o NOSSO sistema gera)
  webhookUrlId       String @unique @default(uuid())
  webhookVerifyToken String @default(uuid())

  // --- Horário de Funcionamento da Clínica ---
  horarioInicio String? // "08:00" - Horário de abertura da clínica
  horarioFim    String? // "18:00" - Horário de fechamento da clínica
  pausaInicio   String? // "12:00" - Início do intervalo de almoço (opcional)
  pausaFim      String? // "13:00" - Fim do intervalo de almoço (opcional)

  // --- Configurações de Módulos ---
  possuiAgenda  Boolean @default(true) // Controla se a clínica tem acesso ao módulo de agendamento
  possuiGerenciar Boolean @default(true) // Controla se a clínica tem acesso ao menu Gerenciar

  // --- Relacionamentos (Quais dados pertencem a esta clínica) ---
  doutores         Doutor[]
  pacientes        Paciente[]
  servicos         Servico[]
  pausaExcecoes    PausaExcecao[]
  conversasInternas ConversaInterna[]
}

model Doutor {
  id            Int     @id @default(autoincrement())
  nome          String
  email         String  @unique
  senha         String
  especialidade String?
  fotoPerfil    String? // URL da foto de perfil

  role  Role    @default(DOUTOR)
  ativo Boolean @default(true)

  // --- Dados Profissionais ---
  crm   String? // Número do CRM (Conselho Regional de Medicina)
  crmUf String? // UF do CRM (ex: "SP", "RJ")
  rqe   String? // RQE (Registro de Qualificação de Especialista)

  // --- Horário de Almoço do Doutor ---
  pausaInicio String? // "12:00" - Início do intervalo de almoço (opcional)
  pausaFim    String? // "13:00" - Fim do intervalo de almoço (opcional)

  // --- Dias Bloqueados (0 = Domingo, 1 = Segunda, ..., 6 = Sábado) ---
  diasBloqueados Int[] @default([]) // Array de dias da semana bloqueados

  // --- Modelo de Prescrição ---
  modeloPrescricao String? @db.Text // HTML/template do modelo de prescrição personalizado

  clinicaId Int?
  clinica   Clinica? @relation(fields: [clinicaId], references: [id], onDelete: Cascade)

  horarios           Horario[]
  agendamentos       Agendamento[]
  indisponibilidades Indisponibilidade[]
  pausaExcecoes      PausaExcecao[]
  servicos           Servico[]
  pacientes          Paciente[]
  prescricoes        Prescricao[]
  atestados          Atestado[] @relation("AtestadosDoutor")
  secretarias        SecretariaDoutor[] @relation("SecretariaVinculos")
  doutoresVinculados SecretariaDoutor[] @relation("DoutorVinculos")
  conversasCriadas   ConversaInterna[]  @relation("ConversasCriadas")
  participacoesChat  ParticipanteConversa[] @relation("ParticipacoesChat")
  mensagensEnviadas  MensagemInterna[]  @relation("MensagensEnviadas")
  leiturasMensagens  LeituraMensagem[]  @relation("LeiturasMensagens")
  statusOnline       StatusUsuario?     @relation("StatusOnline")
  auditLogs          ChatAuditLog[]     @relation("AuditLogs")
}

// Horários que o doutor ATENDE (para a IA saber)
model Horario {
  id          Int     @id @default(autoincrement())
  diaSemana   Int // 0 = Domingo, 1 = Segunda
  inicio      String // "08:00"
  fim         String // "18:00"
  pausaInicio String? // "12:00"
  pausaFim    String? // "14:00"
  doutorId    Int
  doutor      Doutor  @relation(fields: [doutorId], references: [id])
  ativo       Boolean @default(true)
}

model Paciente {
  id       Int     @id @default(autoincrement())
  nome     String
  telefone String
  ativo    Boolean @default(true)

  // Dados de Identificação (Essenciais)
  cpf            String? // CPF como identificador único
  dataNascimento DateTime? // Data de nascimento
  genero         String? // Gênero/Sexo Biológico (ex: "Masculino", "Feminino", "Outro")

  // Dados de Contacto
  email      String? // E-mail para contato
  cep        String? // CEP
  logradouro String? // Rua/Logradouro
  numero     String? // Número do endereço
  bairro     String? // Bairro
  cidade     String? // Cidade
  estado     String? // Estado (UF)

  // Dados Clínicos Básicos
  convenio          String? // Convênio/Plano de Saúde
  numeroCarteirinha String? // Número da carteirinha do convênio
  alergias          String? @db.Text // Alergias (campo de texto)
  observacoes       String? @db.Text // Histórico/Observações (campo de texto livre)
  pesoKg            Float?
  alturaCm          Float?
  foto              String? // URL da foto de perfil do paciente

  agendamentos Agendamento[]
  historicos   HistoricoPaciente[]
  prescricoes  Prescricao[]
  atestados    Atestado[] @relation("AtestadosPaciente")
  chatStatus   ChatStatus          @default(BOT)
  chatMessages ChatMessage[]
  alergiasMedicamentos AlergiaMedicamento[]

  clinicaId Int?
  clinica   Clinica? @relation(fields: [clinicaId], references: [id], onDelete: Cascade)

  doutorId Int?
  doutor   Doutor? @relation(fields: [doutorId], references: [id], onDelete: SetNull)

  @@unique([telefone, clinicaId, ativo])
}

model Servico {
  id           Int           @id @default(autoincrement())
  nome         String
  descricao    String        @db.Text
  duracaoMin   Int
  preco        Float
  ativo        Boolean       @default(true)
  agendamentos Agendamento[]

  clinicaId Int
  clinica   Clinica @relation(fields: [clinicaId], references: [id], onDelete: Cascade)

  doutorId Int?
  doutor   Doutor? @relation(fields: [doutorId], references: [id], onDelete: Cascade)
}

model Agendamento {
  id                 Int                     @id @default(autoincrement())
  dataHora           DateTime
  pacienteId         Int
  paciente           Paciente                @relation(fields: [pacienteId], references: [id], onDelete: Cascade)
  doutorId           Int
  doutor             Doutor                  @relation(fields: [doutorId], references: [id])
  servicoId          Int
  servico            Servico                 @relation(fields: [servicoId], references: [id])
  status             String // "confirmado", "pendente_ia", "cancelado"
  ativo              Boolean                 @default(true)
  relatoPaciente     String?                 @db.Text // O que o paciente disse para realizar o agendamento
  entendimentoIA     String?                 @db.Text // Resumo/análise da IA sobre o que o paciente relatou
  isEncaixe          Boolean                 @default(false) // Indica se é um agendamento em horário parcialmente ocupado
  confirmadoPorMedico Boolean                @default(false) // Indica se o médico confirmou o encaixe (só relevante quando isEncaixe=true)
  motivoCancelamento String?                 @db.Text // Motivo do cancelamento
  canceladoPor       Int? // ID do usuário que cancelou o agendamento
  canceladoEm        DateTime? // Data e hora do cancelamento
  historicos         HistoricoPaciente[]
  prescricoes        Prescricao[]
  atestados          Atestado[] @relation("AtestadosAgendamento")
  prontuarioChats    ProntuarioChatMessage[]
}

model HistoricoPaciente {
  id             Int      @id @default(autoincrement())
  protocolo      String   @unique @default(uuid()) // Protocolo único do atendimento
  descricao      String   @db.Text
  realizadoEm    DateTime @default(now())
  duracaoMinutos Int? // Duração do atendimento em minutos (quando iniciado e finalizado)
  pacienteId     Int
  agendamentoId  Int?
  createdAt      DateTime @default(now())

  paciente    Paciente     @relation(fields: [pacienteId], references: [id], onDelete: Cascade)
  agendamento Agendamento? @relation(fields: [agendamentoId], references: [id], onDelete: SetNull)

  @@index([pacienteId, realizadoEm])
  @@index([protocolo])
}

model Prescricao {
  id            Int      @id @default(autoincrement())
  protocolo     String   @unique @default(uuid()) // Protocolo único da prescrição
  conteudo      String   @db.Text // Texto da prescrição
  invalidado    Boolean  @default(false) // Se a prescrição foi invalidada
  motivoInvalidacao String? @db.Text // Motivo da invalidação
  pacienteId    Int
  doutorId      Int
  agendamentoId Int?
  createdAt     DateTime @default(now())

  paciente    Paciente     @relation(fields: [pacienteId], references: [id], onDelete: Cascade)
  doutor      Doutor       @relation(fields: [doutorId], references: [id], onDelete: Cascade)
  agendamento Agendamento? @relation(fields: [agendamentoId], references: [id], onDelete: SetNull)

  @@index([pacienteId, createdAt])
  @@index([protocolo])
}

model Atestado {
  id              Int      @id @default(autoincrement())
  protocolo       String   @unique @default(uuid()) // Protocolo único do atestado
  diasAfastamento Float    // Dias de afastamento (pode ser decimal para horas)
  horaInicial     String?  // Hora inicial do período (formato HH:mm) - usado quando tipo é horas
  horaFinal       String?  // Hora final do período (formato HH:mm) - usado quando tipo é horas
  cid             String? // CID (opcional)
  exibirCid       Boolean  @default(false) // Se deve exibir o CID no atestado
  conteudo        String   @db.Text // Observações/Recomendações
  localAtendimento String? @default("Consultório") // Local do atendimento
  dataAtestado    DateTime? // Data do atestado (opcional, se não informada usa a data atual)
  invalidado      Boolean  @default(false) // Se o atestado foi invalidado
  motivoInvalidacao String? @db.Text // Motivo da invalidação
  pacienteId      Int
  doutorId        Int
  agendamentoId   Int?
  createdAt       DateTime @default(now())

  paciente    Paciente     @relation("AtestadosPaciente", fields: [pacienteId], references: [id], onDelete: Cascade)
  doutor      Doutor       @relation("AtestadosDoutor", fields: [doutorId], references: [id], onDelete: Cascade)
  agendamento Agendamento? @relation("AtestadosAgendamento", fields: [agendamentoId], references: [id], onDelete: SetNull)

  @@index([pacienteId, createdAt])
  @@index([protocolo])
}

model ChatMessage {
  id           Int        @id @default(autoincrement())
  content      String     @db.Text
  senderType   SenderType
  createdAt    DateTime   @default(now())
  tool_call_id String?
  tool_name    String?
  pacienteId   Int
  paciente     Paciente   @relation(fields: [pacienteId], references: [id], onDelete: Cascade)

  @@index([pacienteId, createdAt])
}

model ThreadCheckpoint {
  id                   String   @id @default(cuid())
  thread_id            String   @unique
  checkpoint           Json
  metadata             Json
  parent_checkpoint_id String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model ProntuarioChatMessage {
  id            Int         @id @default(autoincrement())
  agendamentoId Int
  agendamento   Agendamento @relation(fields: [agendamentoId], references: [id], onDelete: Cascade)
  sender        SenderType
  content       String      @db.Text
  createdAt     DateTime    @default(now())

  @@index([agendamentoId, createdAt])
}

// Períodos em que o doutor está indisponível (cirurgias, afastamentos, etc.)
model Indisponibilidade {
  id        Int      @id @default(autoincrement())
  inicio    DateTime
  fim       DateTime
  motivo    String?  @db.Text
  doutorId  Int
  doutor    Doutor   @relation(fields: [doutorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  ativo     Boolean  @default(true)

  @@index([doutorId, inicio, fim])
}

// Exceções de horário de pausa para um dia específico (clínica ou doutor)
model PausaExcecao {
  id          Int      @id @default(autoincrement())
  data        DateTime @db.Date // Apenas a data (sem hora)
  pausaInicio String // "12:00"
  pausaFim    String // "13:00"
  clinicaId   Int? // Se null, é exceção de doutor
  doutorId    Int? // Se null, é exceção de clínica
  clinica     Clinica? @relation(fields: [clinicaId], references: [id], onDelete: Cascade)
  doutor      Doutor?  @relation(fields: [doutorId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  ativo       Boolean  @default(true)

  @@unique([data, clinicaId, doutorId, ativo])
  @@index([clinicaId, data])
  @@index([doutorId, data])
}

model Medicamento {
  id                       Int       @id @default(autoincrement())
  tipoProduto              String? // TIPO_PRODUTO
  nomeProduto              String // NOME_PRODUTO
  dataFinalizacaoProcesso  DateTime? // DATA_FINALIZACAO_PROCESSO
  categoriaRegulatoria     String? // CATEGORIA_REGULATORIA
  numeroRegistroProduto    String? // NUMERO_REGISTRO_PRODUTO
  dataVencimentoRegistro   DateTime? // DATA_VENCIMENTO_REGISTRO
  numeroProcesso           String? // NUMERO_PROCESSO
  classeTerapeutica        String? // CLASSE_TERAPEUTICA
  empresaDetentoraRegistro String? // EMPRESA_DETENTORA_REGISTRO
  situacaoRegistro         String? // SITUACAO_REGISTRO
  principioAtivo           String?   @db.Text // PRINCIPIO_ATIVO
  ativo                    Boolean   @default(true) // Soft delete: true = ativo, false = inativo
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  alergias AlergiaMedicamento[]

  @@index([nomeProduto])
  @@index([numeroRegistroProduto])
  @@index([classeTerapeutica])
  @@index([ativo])
}

model AlergiaMedicamento {
  id            Int       @id @default(autoincrement())
  pacienteId    Int
  medicamentoId Int?
  nomeMedicamento String  // Nome do medicamento (pode ser de um medicamento cadastrado ou livre)
  principioAtivo String   @db.Text // Princípio ativo (OBRIGATÓRIO - base da verificação)
  classeQuimica String?  @db.Text // Classe química/farmacológica (para reatividade cruzada)
  excipientes   String?  @db.Text // Excipientes/aditivos (ex: látex, corantes, lactose, etc.)
  observacoes   String?  @db.Text // Observações sobre a alergia
  cadastradoPor Int      // ID do doutor que cadastrou
  ativo         Boolean  @default(true) // Soft delete: true = ativo, false = deletado
  deletadoPor   Int?     // ID do doutor que deletou
  justificativaExclusao String? @db.Text // Justificativa para exclusão
  deletadoEm    DateTime? // Data e hora da exclusão
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  paciente   Paciente    @relation(fields: [pacienteId], references: [id], onDelete: Cascade)
  medicamento Medicamento? @relation(fields: [medicamentoId], references: [id], onDelete: SetNull)

  @@index([pacienteId])
  @@index([medicamentoId])
  @@index([nomeMedicamento])
  @@index([principioAtivo])
  @@index([ativo])
}

// Vínculo entre Secretária e Doutor
model SecretariaDoutor {
  id           Int      @id @default(autoincrement())
  secretariaId Int      // ID do doutor com role SECRETARIA
  doutorId     Int      // ID do doutor vinculado
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  secretaria Doutor @relation("SecretariaVinculos", fields: [secretariaId], references: [id], onDelete: Cascade)
  doutor     Doutor @relation("DoutorVinculos", fields: [doutorId], references: [id], onDelete: Cascade)

  @@unique([secretariaId, doutorId])
  @@index([secretariaId])
  @@index([doutorId])
}

// ============================================
// CHAT INTERNO DA CLÍNICA
// ============================================

enum ChatInternoTipo {
  INDIVIDUAL  // Conversa 1:1 entre dois usuários
  GRUPO       // Grupo com múltiplos participantes
}

enum MensagemInternaTipo {
  TEXTO
  IMAGEM
  PDF
  EMOJI
}

enum MensagemInternaStatus {
  ENVIADA     // Mensagem foi enviada
  ENTREGUE    // Mensagem foi entregue ao destinatário
  LIDA        // Mensagem foi lida pelo destinatário
}

// Conversa do chat interno (pode ser individual ou grupo)
model ConversaInterna {
  id          Int                @id @default(autoincrement())
  tipo        ChatInternoTipo
  nome        String?            // Nome do grupo (null para conversas individuais)
  descricao   String?            @db.Text // Descrição do grupo
  clinicaId   Int                // Todas as conversas pertencem a uma clínica
  clinica     Clinica            @relation(fields: [clinicaId], references: [id], onDelete: Cascade)
  criadoPor   Int                // ID do usuário que criou a conversa
  criador     Doutor             @relation("ConversasCriadas", fields: [criadoPor], references: [id])
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  
  // Relacionamentos
  participantes ParticipanteConversa[]
  mensagens     MensagemInterna[]
  
  @@index([clinicaId, updatedAt])
  @@index([criadoPor])
}

// Participantes de uma conversa (usuários que fazem parte)
model ParticipanteConversa {
  id              Int             @id @default(autoincrement())
  conversaId      Int
  conversa        ConversaInterna @relation(fields: [conversaId], references: [id], onDelete: Cascade)
  usuarioId       Int             // ID do Doutor (que pode ter role DOUTOR, SECRETARIA, etc.)
  usuario         Doutor          @relation("ParticipacoesChat", fields: [usuarioId], references: [id], onDelete: Cascade)
  adicionadoPor   Int?            // Quem adicionou este participante
  adicionadoEm    DateTime        @default(now())
  ultimaLeitura   DateTime?       // Timestamp da última mensagem lida por este participante
  notificacoes    Boolean         @default(true) // Se recebe notificações desta conversa
  
  @@unique([conversaId, usuarioId])
  @@index([usuarioId])
  @@index([conversaId, ultimaLeitura])
}

// Mensagens do chat interno
model MensagemInterna {
  id              Int                    @id @default(autoincrement())
  conversaId      Int
  conversa        ConversaInterna       @relation(fields: [conversaId], references: [id], onDelete: Cascade)
  remetenteId     Int                    // ID do Doutor que enviou
  remetente       Doutor                 @relation("MensagensEnviadas", fields: [remetenteId], references: [id])
  tipo            MensagemInternaTipo    @default(TEXTO)
  conteudo        String                 @db.Text // Texto da mensagem ou caminho do arquivo
  conteudoCriptografado String?          @db.Text // Conteúdo criptografado para mensagens sensíveis
  status          MensagemInternaStatus  @default(ENVIADA)
  editada         Boolean                @default(false)
  editadaEm       DateTime?
  createdAt       DateTime               @default(now())
  
  // Para rastreamento de leitura por destinatário
  leituras        LeituraMensagem[]
  
  @@index([conversaId, createdAt])
  @@index([remetenteId])
  @@index([status])
}

// Rastreamento de leitura de mensagens
model LeituraMensagem {
  id          Int            @id @default(autoincrement())
  mensagemId  Int
  mensagem    MensagemInterna @relation(fields: [mensagemId], references: [id], onDelete: Cascade)
  usuarioId   Int            // ID do Doutor que leu
  usuario     Doutor         @relation("LeiturasMensagens", fields: [usuarioId], references: [id], onDelete: Cascade)
  lidaEm      DateTime       @default(now())
  
  @@unique([mensagemId, usuarioId])
  @@index([usuarioId])
}

// Status online/offline dos usuários
model StatusUsuario {
  id          Int       @id @default(autoincrement())
  usuarioId   Int       @unique // ID do Doutor
  usuario     Doutor    @relation("StatusOnline", fields: [usuarioId], references: [id], onDelete: Cascade)
  online      Boolean   @default(false)
  ultimaVezOnline DateTime?
  digitandoEmConversaId Int? // ID da conversa em que está digitando
  
  @@index([online, ultimaVezOnline])
}

// Logs de auditoria do chat
model ChatAuditLog {
  id          Int       @id @default(autoincrement())
  usuarioId   Int?      // ID do Doutor que executou a ação
  usuario     Doutor?   @relation("AuditLogs", fields: [usuarioId], references: [id], onDelete: SetNull)
  acao        String    // "LOGIN", "ENVIO_MENSAGEM", "CRIACAO_GRUPO", "ADICIONAR_PARTICIPANTE", etc.
  detalhes    String?   @db.Text // JSON com detalhes da ação
  ip          String?
  userAgent   String?
  createdAt   DateTime  @default(now())
  
  @@index([usuarioId, createdAt])
  @@index([acao, createdAt])
}

